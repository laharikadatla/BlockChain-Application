# Importing
import hashlib, os, json, requests
from time import time
from merkletree import MerkleTree
from Crypto.Signature import PKCS1_v1_5
from Crypto.Hash import SHA256
from Crypto.PublicKey import RSA

private_key = None
MINING_DIFFICULTY = 2
# Block class represents a single block of our blockchain
    # hash: The signed merkle hash of this block
    # previous_hash: The hash of the previous block in the blockchain
    # timestamp: The timestamp of the block (automatically generated by default)
    # transactions: A list of transaction which are included in the block
    # proof: The proof of work number that yielded this block
class Block:
    def __init__(self, index, previous_hash, transactions, proof, time=time() ):
        self.index = index
        self.previous_hash = previous_hash
        self.timestamp = time
        self.transactions = transactions
        self.proof = proof
        self.hash = self.calculateHash()
    
    def calculateHash(self):
        server_private_key = private_key if private_key else RSA.import_key( open( os.getcwd() + "/keys/server_private_key.pem", "r" ).read() )
        signer = PKCS1_v1_5.new(server_private_key)
        if self.transactions :
            # calculate merkle hash and sign hash
            mtree = MerkleTree(self.transactions)
            signed_hash = signer.sign(mtree.root.hash_obj)
            return signed_hash
        else:
            # Assuming as genesis block 
            block_string = json.dumps(self.__dict__, sort_keys=True).encode()
            digest = SHA256.new()
            digest.update(block_string)
            signed_hash = signer.sign(digest)
            return signed_hash




# This class manages the chain of blocks, open transactions and the node on which it's running
#    chain: The list of blocks
#    open_transactions (private): The list of open transactions
#    hosting_node: The connected node (which runs the blockchain)
class Blockchain:
    def __init__(self, privateKey=None):
        # Genesis block is the very first block in our blockchain
        global private_key
        private_key = privateKey
        genesis_block = Block(0, '', [], 100)
        # Initializing our blockchain list
        self.chain = [genesis_block]
        self.__open_transactions = []

    @property
    def chain(self):
        return self.__chain[:]

    @chain.setter
    def chain(self, val):
        self.__chain = val

    def get_open_transactions(self):
        return self.__open_transactions[:]
    
    def add_open_transactions(self, transactions):
        self.__open_transactions = transactions

    # Generate a proof of work for open transactions, hash of previous block and a random number(Which is guessed until it fits)
    def proof_of_work(self):
        last_block = self.__chain[-1]
        previous_proof = last_block.proof
        new_proof = 1
        # status of proof of work
        check_proof = False
        while check_proof is False:
           hash_operation = hashlib.sha256(str(new_proof ** 2 - previous_proof ** 2).encode()).hexdigest()
           # check miners solution to problem, by using miners proof in cryptographic encryption
           # if miners proof results in 4 leading zero's in the hash operation, then:
           if hash_operation[:MINING_DIFFICULTY] == '00':
               check_proof = True
           else:
               new_proof += 1
        return new_proof


    #  Returns the last value of the current blockchain
    def get_last_blockchain_value(self):
        if len(self.__chain) < 1:
            return None
        return self.__chain[-1]

   # Mine a new block in the Blockchain ( Create a new block and add transactions to it )
    def mine_block(self):
        last_block = self.__chain[-1]
        # Hash the last block. So, we can compare it to the stored hash value
        hashed_block = last_block.hash
        proof = self.proof_of_work()
        copied_transactions = self.__open_transactions[:]
        block = Block(len(self.__chain), hashed_block,
                      copied_transactions, proof )
        self.__chain.append(block)
        self.__open_transactions = []
        return block
   
    def is_chain_valid(self):
       # get the first block in the chain and it serves as the previous block
        previous_block = self.__chain[0]
        # an index of the blocks in the chain for iteration
        block_index = 1
        while block_index < len(self.__chain):
            # get the current block
            block = self.__chain[block_index]
            # check if the current block link to previous block has is the same as the hash of the previous block
            if block.previous_hash != previous_block.hash:
                return False

            # get the previous proof from the previous block
            previous_proof = previous_block.proof

            # get the current proof from the current block
            current_proof = block.proof

            # run the proof data through the algorithm
            hash_operation = hashlib.sha256(str(current_proof ** 2 - previous_proof ** 2).encode()).hexdigest()
            # check if hash operation is invalid
            if hash_operation[:MINING_DIFFICULTY] != '00':
                return False
            # set the previous block to the current block after running validation on current block
            previous_block = block
            block_index += 1
        return True
